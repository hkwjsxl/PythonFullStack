# 考核题

## 模块1

### 1 Py2和Py3的区别

~~~python
Py2整数做除法是地板除，py3整数做除法是可以有小树的
默认编码不同，前者是ascii，后者为utf-8
个别的方法不同，前者是print ***，后者为print(***)
项目规范不同，前者包下必须有__init__.py，后者可有可无
在Py2中 字典.keys()、.values()、.items()直接获取到的是列表，而Py3中返回的是高仿列表，这个高仿的列表可以被循环显示
py2分整型和长整形，py3不分
py2字典无序；py3.6+ 字典有序。
对象继承的不同，前者分为经典类（不继承Object）和新式类（继承Object），后者默认都是新式类
	经典类（从左到右，深度优先，大小钻石，不留顶端），新式类（从左到右，深度优先，大小钻石，保留顶端 -- C3算法）

~~~

### 2 简述深浅拷贝

~~~python

赋值:将变量和值在内存中形成映射指向关系
浅拷贝:只拷贝第一层级里的所有元素,单独开辟空间成型独立的一份副本copy.copy()
深拷贝:所有层级的元素都单独拷贝一份,开辟全新的空间copy.deepcopy()
原不可变数据只是暂时的指向原数据(值更改后内存地址会发生变化),可变的数据独立开辟新空间

深浅拷贝是针对于可变类型，不可变类型无任何意义，内存地址不会改变
浅拷贝
    不可变类型：不会拷贝
    可变类型：只拷贝第一层（值拷贝，源对象数据发生改变时，浅拷贝对象的值一起发生改变）
深拷贝
    不可变类型：不会拷贝（特殊：元组类型，当元组中有可变类型时，会拷贝元组）
    可变类型：拷贝可变类型的所有层，并且拷贝元组中可变类型的所有层（内存地址的拷贝，源对象数据发生改变时，深拷贝对象的值不会发生改变）
~~~

### 3 基础数据类型

~~~python
# 有哪些，哪些可变哪些不可变

可变：dict, list, set
不可变：str, int, tuple, froenset, bool, float, 
~~~

### 4 Is和==的区别

~~~python
Is是比较的内存地址
==是比较的值
~~~

### 5 机器语言、汇编语言和高级语言的特点

~~~python
1.难学，难懂，难理解，无通用性，运行速度最快，开发效率最低，计算机能直接执行
2.执行效率高，占用存储空间小
3.容易，开发效率最高，有一定的通用性，计算机不能直接识别和执行
~~~

### 6 Python常见解释器

~~~python
Cpython, Jpython, PyPy, ironPython
~~~

### 7 list常见内置方法

~~~python
append, insert, extend, pop, count, sorted, reverse, copy
~~~

### 8 元组是否能作为字典的key

~~~python
当元组中不存在不可哈希类型时，可以作为字典的Key，反之不行。
~~~

### 9 各种编码

~~~python
ascii编码、unicode字符集、utf-8编码、gbk编码本质上都是字符与二进制的关系。
- ascii，只有256种对照关系，只包含英文、符号等。
- unicode，万国码，包含了全球所有文字和二进制之间的一个对应关系。（ucs2或ucs4）
- utf-8，对unicode字符集的码位进行压缩处理，间接也维护了字符和二进制的对照表。
- gbk，包含中国、日本韩国等亚洲国家的文字和二进制的对照表。
~~~

### 10 什么情况下，下面的解释不正确

~~~python
y != x - (x - y)

集合：非空集合并且不包含父子关系
~~~




## 模块2

### 1 写一个简单随机4位验证码

~~~python
import random
import string
import itertools

def main():
    code = ''
    code_list = list(itertools.chain(string.digits, string.ascii_letters))
    print(code_list)
    for i in range(4):
        choice = random.choice(code_list)
        code += choice
    print(code)


if __name__ == '__main__':
    main()
    ...
~~~

### 2 迭代器的好处

~~~python
迭代器统一了对容器的访问方式
可以直接用for循环进行遍历
占用内存小
~~~

### 3 Python的执行过程

~~~python
"""
Python在执行时可能会产生一个字节码文件，当我们执行一个脚本时，脚本引入的模块会产生pyc文件

解释型语言和编译型语言
计算机是不能够识别高级语言的，所以当我们运行一个高级语言程序时，就需要一个“翻译机”来从事把高级语言转变成计算机能够读懂的机器语言的过程。
这个过程分为两类，第一种是编译，第二种是解释

编译型语言在程序执行之前，先会通过编译器对程序执行一个编译的过程，把程序变成机器语言。运行时就不用翻译，而是直接运行就可以了，最典型的是C语言
解释型语言就是没有这个编译的过程，而是在程序运行的时候，通过解释器对程序逐行做出解释，然后直接运行，例如ruby
还有第三种，是Java这种，先编译后解释。

我们的Python也是属于那种先编译后解释的语言，
当Python程序运行时，编译结果则是保存在位于内存中的PyCodeObject中，
当Python程序运行结束时，Python解释器则将PyCodeObject写回到pyc文件中。
当Python程序第二次运行时，首先程序会在硬盘上寻找对应的pyc文件，如果找到，则直接载入，否则就重复上面的过程

Python执行的过程：
所以可以认定，Python它面向对象更彻底了，比JAVA中的一切皆对象更彻底，JAVA中有class，也就是类的概念，object是class的一个实例。
但是Python中函数和类也是对象
"""

"""
过程说明
1、Python程序首次运行时，编译的结果保存在内存中的PycodeObject中。
Python程序运行结束时，Python解释器将PycodeObject写回硬盘的pyc文件。
2、Python程序第二次运行时，首先程序会在硬盘中找到pyc文件，如果找到，直接装载，否则重复上述过程。
因此，应该这样定位PyCodeObject和pyc文件。pyc文件实际上是PyCodeObject的持久保存方式。
也就是说，保存pyc文件是为了避免在下次再次使用该剧本时重复编译，节省时间。因此，只执行一次脚本，就没有必要保存其编译结果pyc文件浪费空间。
"""

~~~

### 4 如何区分类中的函数和方法

~~~
"""类直接调用函数是函数，类实例化后调用函数是方法"""
from types import MethodType, FunctionType
class Foo(object):
    def fetch(self):
        pass
print(isinstance(Foo.fetch, MethodType))
print(isinstance(Foo.fetch, FunctionType))  # True
obj = Foo()
print(isinstance(obj.fetch, MethodType))  # True
print(isinstance(obj.fetch, FunctionType))
~~~

