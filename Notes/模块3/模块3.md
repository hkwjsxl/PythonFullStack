    **1、简述面向对象的三大特性**
    封装
        将一些属性或方法封装到类里面，可供外部调用或隐藏
        封装原则：高内聚，低耦合
    继承
        将子类的数据封装到父类中，供子类使用，将多个子类的方法封装到同一类型中，提高代码重用性
    多态
        本身具有多态特性，提倡鸭子类型，不在乎传入的参数是什么类型，只要有对应的方法即可
    
    
    **2、super 的作用?**
    根据mro向上查找父类，在重写父类方法时，可以保留父类功能
    
    
    **3、列举带双下划线的特殊方法**
    __init__
    __new__
    __enter__
    __exit__
    __call__
    __str__
    __del__
    
    **4、实例变量和类变量的区别?**
    实例变量属于对象
    类变量属于类
    
    
    **5、异常处理，假如有个写sql的操作异常，需要捕获这种异常，并最终释放mysql连接**
    
    ```python
    def conn_mysql():
        """
        连接数据库
        :return: 
        """
        print("连接成功")
    
    
    def insert_content():
        """
        写数据
        :return: 
        """
        xxx
        print("写成功")
    
    
    def close_conn():
        """
        释放数据库连接
        :return: 
        """
        print("释放连接")
    
    try:
        conn_mysql()
        insert_content()
    
    # except Exception as e:
    #     print(e)
    # finally:
    #     close_conn()
    #
    ...
    ```
    
    
    
    **6、反射**
    
    （1）获取mem的name属性值
    
    （2）判断mem是否有age属性
    
    ```python
    class Member:
        def __init__(self, name, age):
            self.name = name
            self.age = age
    
        def show(self):
            msg = "name: {}, age: {}".format(self.name, self.age)
            return msg
    
    mem = Member("hkw", 18)
    
    # getattr(mem, 'name')
    # hasattr(mem, 'age')
    
    ```
    
    
    
    **7、网络基础**
    
    （1）OSI7层模型
        应用层，表示层，会话层，传输层，网络层，数据链路层，物理层
    
    （2）传输层的代表协议
        TCP，UDP
    
    （3）应用层的代表协议
        HTTP,SMTP,FTP,POP3,DNS
    
    （4）TCP和UDP的区别
        前者必须先建立连接，保障了数据的完整性，多用于网站和文件传输
        后者无需建立连接，不保证数据的完整性，但头部开销小，只有8个字节，多用于音视频或直播
    
    （5）以浏览器打开百度为例，叙述一下中间网络传输经历的过程
        浏览器输入www.baidu.com，浏览器对输入的内容进行解析，判断url的合法性和是否有可用的缓存
        在通过DNS解析出百度的ip地址
        浏览器向百度服务器建立三次握手
        浏览器向百度服务器发送http请求
        浏览器接收百度服务器返回的http响应
        数据传输完成后，四次挥手关闭连接
        浏览器页面渲染百度服务器返回的数据
    
    （6）socket通信过程
        服务端创建一个socket，然后绑定（bind）ip和端口，并开始监听（listen）
        客户端也创建一个socket，然后根据服务端的ip和端口，链接（connect）服务端
        服务端监听接收到客户端的请求（accept），这样连接就创建好了
        连接成功之后可以发送（send）和接收（recv）数据
        数据传送完毕后可以各自通过close关闭连接
    
    **8、线程和进程的概念，多进程和多线程分别应用在哪类不同的场景**
        进程：计算机分配资源的最小单元，
        线程：cpu所调用的最小单元,同一进程的多个线程之间资源共享
        计算密集型用多进程
        IO密集型用多线程
    
    **9、GIL锁的概念**
        全局解释器锁，Cpython所独有，让一个进程中同一时刻内仅有一个线程可以被cpu所调用
    
    **10、什么叫死锁**
        当两个进程（线程）拿着对方所需要的锁时，在对方没有释放锁时要互相请求对方手里的锁，就会进入阻塞状态，也就是死锁
    
    另外：__pycache__里面存放了些文件，怎么产生的？
        字节码文件
    
        计算机不能识别python源代码，所以python解释器在运行py文件时，会先完成模块的加载和链接，
        编译成字节码文件，写入内存中，供cpu读取，
        从内存中读取字节码文件并执行，完事之后再将字节码文件写入硬盘中，
        之后若再次运行此py文件，先检查本地是否有对应的字节码文件和字节码文件的修改时间是否在脚本文件的时间之后，
        是的话就执行，否则重复上述步骤
    
        第一次执行代码时，python解释器将编译的结果存放到pycache文件中，下次在运行时，如果被调用的模块未发生改变，就直接运行已有的字节码文件，
        不再重新的编译，节省了资源和时间。
    
    
    计算机不能识别python源代码，所以python解释器在运行py文件时，会先完成模块的加载和链接，
    编译成字节码文件，写入内存中，供cpu读取，
    从内存中读取字节码文件并执行，完事之后再将字节码文件写入硬盘中，
    之后若再次运行此py文件，先检查本地是否有对应的字节码文件和字节码文件的修改时间是否在脚本文件的时间之后，
    是的话就执行，否则重复上述步骤
    
    第一次执行代码时，python解释器将编译的结果存放到pycache文件中，下次在运行时，如果被调用的模块未发生改变，就直接运行已有的字节码文件，
    不再重新的编译，节省了资源和时间。
