### 基础题

#### 写一个带参数的闭包

~~~python
from functools import wraps
def outer(n):
    @wraps(n)
    def wrapper(func):
        def inner(*args, **kwargs):
            print("inner")
            print(n)
            return func(*args, **kwargs)

        return inner

    return wrapper
@outer("123")
def func():
    print("func")
func()
~~~

#### 写出结果

~~~python
def func():
    return [lambda x: x * i for i in range(4)]


res = [j(2) for j in func()]
print(res)
~~~

#### def func(a,b=[])这种写法有什么问题吗

~~~python
def func():
    return [lambda x: x * i for i in range(4)]


res = [j(2) for j in func()]
print(res)
~~~

#### 写出结果

~~~python
def func(a, b=[]):
    b.append(a)
    return b
v1 = func(1)  # [1]
v2 = func(2, [10, 20])  # [10, 20, 2]
v3 = func(3)  # [1, 3]
print(v1, v2, v3)
~~~

#### 补零

~~~python
ip = "192.168.10.1"
for s in ip.split("."):
    print(s.zfill(8))
~~~

#### 取整

~~~python
import math
i = 5.5
print(math.floor(i))  # 地板取整
print(math.ceil(i))  # 天花板取整
~~~

#### 用两个队列实现一个栈

~~~python
# 用两个队列实现一个栈
from queue import Queue


class Q:
    def __init__(self):
        self.master_queue = Queue()
        self.sub_queue = Queue()

    def push(self, val):
        self.master_queue.put(val)
        return self.master_queue

    def pop(self):
        if self.master_queue.qsize() == 0:
            return None
        while True:
            if self.master_queue.qsize() == 1:
                value = self.master_queue.get()
                break
            self.sub_queue.put(self.master_queue.get())
        self.master_queue, self.sub_queue = self.sub_queue, self.master_queue
        return value


if __name__ == '__main__':
    q = Q()
    q.push(1)
    q.push(2)
    q.push(3)
    print(q.pop())
    print(q.pop())
    print(q.pop())
    print(q.pop())

~~~

#### 实现一个链表

~~~python
# 单链表
class Node:
    def __init__(self, value, next_node):
        self.value = value
        self.next_node = next_node


node = Node("head", None)
next_node = node

for i in range(3):
    new_node = Node("%s" % i, None)
    next_node.next_node = new_node
    next_node = new_node

print(node.value)
print(node.next_node.value)
print(node.next_node.next_node.value)
print(node.next_node.next_node.next_node.value)
~~~

#### 单链表（实现逆转）

~~~python
# 单链表（实现逆转）
class Node:
    def __init__(self, value, next_node, prev_node):
        self.value = value
        self.next_node = next_node
        self.prev_node = prev_node


node = Node("head", None, None)
next_node = node

for i in range(3):
    new_node = Node("%s" % i, None, next_node)
    next_node.next_node = new_node
    next_node = new_node

print(node.value)
print(node.next_node.value)
print(node.next_node.next_node.value)
print(node.next_node.next_node.next_node.value)
print(node.next_node.next_node.next_node.prev_node.value)
print(node.next_node.next_node.next_node.prev_node.prev_node.value)
print(node.next_node.next_node.next_node.prev_node.prev_node.prev_node.value)
~~~

#### 双向循环链表

~~~python
# 双向循环链表
class Node:
    def __init__(self, value, next_node, prev_node):
        self.value = value
        self.next_node = next_node
        self.prev_node = prev_node


node = Node("head", None, None)
next_node = node

for i in range(3):
    new_node = Node("%s" % i, None, next_node)
    next_node.next_node = new_node
    next_node = new_node
next_node.next_node = node
node.prev_node = next_node

print(node.value)
print(node.next_node.value)
print(node.next_node.next_node.value)
print(node.next_node.next_node.next_node.value)
print(node.next_node.next_node.next_node.next_node.value)
print(node.next_node.next_node.next_node.next_node.next_node.value)
print(node.next_node.next_node.next_node.next_node.next_node.next_node.value)
print(node.next_node.next_node.next_node.next_node.next_node.next_node.next_node.value)
~~~
