"""
小美的01串翻转（美团0819）
小美定义一个 01 串的权值为：每次操作选择一位取反，使得相邻字符都不相等的最小操作次数。

例如，"10001"的权值是 1，因为只需要修改一次：对第三个字符取反即可。

现在小美拿到了一个 01 串，她希望你求出所有非空连续子串的权值之和，你能帮帮她吗？

输入描述
一个仅包含’0’和’1’的字符串，长度不超过 2000。

输出描述
所有非空子串的权值和。

示例1
输入
10001

输出
8

说明
长度为 2 的子串中，有 2 个"00"的权值是 1。
长度为 3 的 3 个子串权值都是 1。
长度为 4 的 2 个子串权值都是 1。
长度为 5 的 1 个子串权值是 1。
总权值之和为 2+3+2+1=8

思路与代码
前缀和模拟。
不难发现，最后的序列必然是 10101…或者是 010101…，因此对于长度为n的序列，最后的结果只有2种可能。枚举其中的最小值即可。

pres1和pres2分别表示两种可能的修改次数的前缀和。
枚举所有可能的子串，使用前缀和快速求得区间的修改次数（权值），叠加即可。
"""
s = [int(c) for c in input()]

n = len(s)

# 枚举第一位就好了
s1 = list(s)
s2 = list(s)

s2[0] ^= 1

for i in range(1, n):
    s1[i] = s1[i - 1] ^ 1
    s2[i] = s2[i - 1] ^ 1

pres1, pres2 = [0] * (n + 1), [0] * (n + 1)

for i in range(1, n + 1):
    pres1[i], pres2[i] = pres1[i - 1], pres2[i - 1]
    # //需要改动，则次数+1
    if s[i - 1] != s1[i - 1]: pres1[i] += 1
    if s[i - 1] != s2[i - 1]: pres2[i] += 1

res = 0
# //将不同情况字串的结果相加
for i in range(n):
    for j in range(i + 1, n):
        res += min(pres1[j + 1] - pres1[i], pres2[j + 1] - pres2[i])

print(res)
