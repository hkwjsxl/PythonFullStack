"""
最长连续子数组
给定一个由若干 0 和 1 组成的数组 A，我们最多可以将 K 个值从 0 变成 1 ，返回仅包含 1 的最长（连续）子数组的长度
时间限制：C/C++ 1秒，其他语言2秒
空间限制：C/C++ 256M，其他语言512M
示例1
输入例子：
[1,1,1,0,0,0,1,1,1,1,0],2
输出例子：
6
例子说明：
可以将输入中的第3个0和第4个0变成1，新数组为[1,1,1,0,0,1,1,1,1,1,1]，因此最长连续1的子数组长度为6
示例2
输入例子：
[0,0,1,1,0,0,1,1,1,0,1,1,0,0,0,1,1,1,1],3
输出例子：
10
例子说明：
可以将输入中的第3个0、第4个0，第5个0都变成1，新数组为[0,0,1,1,1,1,1,1,1,1,1,1,0,0,0,1,1,1,1]，因此最长连续1的子数组长度为10
"""

"""
打牌

基本思路：题目提供k次机会把0翻转成1，相当于你手上有k张牌。

右指针right 遍历数组，遇到0就“出牌”，手上的牌就少了。出到负数的时候，就要移动left 前进，遇到0才 “抽牌”，牌又多了

right和left之间的最长区间就是 连续1的最大个数
"""


class Solution:
    def GetMaxConsecutiveOnes(self, arr, k):
        left = right = res = 0
        while right < len(arr):
            if arr[right] == 0:
                k -= 1
            while k < 0:
                if arr[left] == 0:
                    k += 1
                left += 1
            res = max(res, right - left + 1)
            right += 1
        return res


ret = Solution().GetMaxConsecutiveOnes([1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 0], 2)
print(ret)
ret = Solution().GetMaxConsecutiveOnes([0,0,1,1,0,0,1,1,1,0,1,1,0,0,0,1,1,1,1],3)
print(ret)
